
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ripyl Package &mdash; Ripyl 1.2 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/ripyl.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Ripyl 1.2 documentation" href="../index.html" />
    <link rel="up" title="ripyl" href="modules.html" />
    <link rel="next" title="protocol Package" href="ripyl.protocol.html" />
    <link rel="prev" title="ripyl" href="modules.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ripyl.protocol.html" title="protocol Package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="ripyl"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Ripyl 1.2 documentation</a> &raquo;</li>
          <li><a href="modules.html" accesskey="U">ripyl</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="ripyl-package">
<h1>ripyl Package<a class="headerlink" href="#ripyl-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">ripyl</span></tt> Package<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-ripyl.__init__"></span><p>Ripyl protocol decode library</p>
</div>
<div class="section" id="module-ripyl.config">
<span id="config-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">config</span></tt> Module<a class="headerlink" href="#module-ripyl.config" title="Permalink to this headline">¶</a></h2>
<p>Manage Ripyl configuration data</p>
<dl class="class">
<dt id="ripyl.config.ConfigSettings">
<em class="property">class </em><tt class="descclassname">ripyl.config.</tt><tt class="descname">ConfigSettings</tt><a class="headerlink" href="#ripyl.config.ConfigSettings" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Container for general ripyl library settings</p>
<dl class="method">
<dt id="ripyl.config.ConfigSettings.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.config.ConfigSettings.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.config.ConfigSettings.cython_active">
<tt class="descname">cython_active</tt><a class="headerlink" href="#ripyl.config.ConfigSettings.cython_active" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify if Cython modules have been monkeypatched</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if any patches have been applied</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.config.ConfigSettings.find_patch_obj">
<tt class="descname">find_patch_obj</tt><big>(</big><em>obj_path</em><big>)</big><a class="headerlink" href="#ripyl.config.ConfigSettings.find_patch_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for a PatchObject by name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>obj_path</strong> (<em>string</em>) &#8211; Full path to the object in dotted notation (ex: &#8216;ripyl.module.object&#8217;)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A patchobject if found or none.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.config.PatchObject">
<em class="property">class </em><tt class="descclassname">ripyl.config.</tt><tt class="descname">PatchObject</tt><big>(</big><em>py_mname</em>, <em>obj_name</em>, <em>obj</em>, <em>orig_obj</em><big>)</big><a class="headerlink" href="#ripyl.config.PatchObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Represent a monkeypatch object</p>
<p>This class provides a means to track and control pairs of class and function objects
that can be swapped at will. This allows simplified monkeypatching for replacing
python code with Cython equivalents.</p>
<dl class="method">
<dt id="ripyl.config.PatchObject.__init__">
<tt class="descname">__init__</tt><big>(</big><em>py_mname</em>, <em>obj_name</em>, <em>obj</em>, <em>orig_obj</em><big>)</big><a class="headerlink" href="#ripyl.config.PatchObject.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>py_mname</strong> (<em>string</em>) &#8211; The name of the module containing the original python object in dotted notation</li>
<li><strong>obj_name</strong> (<em>string</em>) &#8211; The name of the object to be patched</li>
<li><strong>obj</strong> (<em>function or class object</em>) &#8211; Reference to the replacement object patched over the original</li>
<li><strong>orig_obj</strong> (<em>function or class object</em>) &#8211; Reference to the original object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.config.PatchObject.activate">
<tt class="descname">activate</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.config.PatchObject.activate" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the monkeypatch over the orignal object</p>
</dd></dl>

<dl class="method">
<dt id="ripyl.config.PatchObject.revert">
<tt class="descname">revert</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.config.PatchObject.revert" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore the original object is it was previously monkeypatched</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.config.write_config">
<tt class="descclassname">ripyl.config.</tt><tt class="descname">write_config</tt><big>(</big><em>cfg_path</em>, <em>use_cython</em>, <em>cython_prebuild</em><big>)</big><a class="headerlink" href="#ripyl.config.write_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a file for the Ripyl build configuration</p>
</dd></dl>

</div>
<div class="section" id="module-ripyl.decode">
<span id="decode-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">decode</span></tt> Module<a class="headerlink" href="#module-ripyl.decode" title="Permalink to this headline">¶</a></h2>
<p>General routines shared between decoders</p>
<dl class="class">
<dt id="ripyl.decode.EdgeSequence">
<em class="property">class </em><tt class="descclassname">ripyl.decode.</tt><tt class="descname">EdgeSequence</tt><big>(</big><em>edges</em>, <em>time_step</em>, <em>start_time=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.EdgeSequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Utility class to walk through an edge iterator in arbitrary time steps</p>
<dl class="method">
<dt id="ripyl.decode.EdgeSequence.__init__">
<tt class="descname">__init__</tt><big>(</big><em>edges</em>, <em>time_step</em>, <em>start_time=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.EdgeSequence.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>edges</strong> (<em>sequence of (float, int) tuples</em>) &#8211; An iterable of 2-tuples representing each edge transition.
The 2-tuples <em>must</em> be in the absolute time form (time, logic level).</li>
<li><strong>time_step</strong> (<em>float</em>) &#8211; The default time step for advance() when it is called
without an argument.</li>
<li><strong>start_time</strong> (<em>float</em>) &#8211; The initial starting time for the sequence.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:raises:  StreamError when there are less than two elements to the edges iterable</p>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.EdgeSequence.advance">
<tt class="descname">advance</tt><big>(</big><em>time_step=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.EdgeSequence.advance" title="Permalink to this definition">¶</a></dt>
<dd><p>Move forward through edges by a given amount of time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>time_step</strong> (<em>float</em>) &#8211; The amount of time to move forward. If None, the default
time_step from the constructor is used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.EdgeSequence.advance_to_edge">
<tt class="descname">advance_to_edge</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.decode.EdgeSequence.advance_to_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance to the next edge in the iterator after the current time</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The amount of time advanced as a float.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.EdgeSequence.at_end">
<tt class="descname">at_end</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.decode.EdgeSequence.at_end" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True when the edge iterator has terminated</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.EdgeSequence.cur_state">
<tt class="descname">cur_state</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.decode.EdgeSequence.cur_state" title="Permalink to this definition">¶</a></dt>
<dd><p>The logic level of the edge iterator at the current time</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.decode.MultiEdgeSequence">
<em class="property">class </em><tt class="descclassname">ripyl.decode.</tt><tt class="descname">MultiEdgeSequence</tt><big>(</big><em>edge_sets</em>, <em>time_step</em>, <em>start_time=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Utility class to walk through a group of edge iterators in arbitrary time steps</p>
<dl class="method">
<dt id="ripyl.decode.MultiEdgeSequence.__init__">
<tt class="descname">__init__</tt><big>(</big><em>edge_sets</em>, <em>time_step</em>, <em>start_time=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>edge_sets</strong> (<em>dict</em>) &#8211; A dict of edge sequence iterators keyed by the string name of the channel</li>
<li><strong>time_step</strong> (<em>float</em>) &#8211; The default time step for advance() when it is called
without an argument.</li>
<li><strong>start_time</strong> (<em>float</em>) &#8211; The initial starting time for the sequence.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.MultiEdgeSequence.advance">
<tt class="descname">advance</tt><big>(</big><em>time_step=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence.advance" title="Permalink to this definition">¶</a></dt>
<dd><p>Move forward through edges by a given amount of time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>time_step</strong> (<em>float</em>) &#8211; The amount of time to move forward. If None, the default
time_step from the constructor is used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.MultiEdgeSequence.advance_to_edge">
<tt class="descname">advance_to_edge</tt><big>(</big><em>channel_name=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence.advance_to_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance to the next edge among the edge sets or in a named channel
after the current time</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>channel_name</strong> (<em>string</em>) &#8211; If None, the edge sets are advanced to the closest edge after the current
time. if a valid channel name is provided the edge sets are advanced to
the closest edge on that channel.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A tuple (time, channel_name) representing the amount of time advanced
as a float and the name of the channel containing the edge. If there are no
unterminated edge sequences then the tuple (0,0, &#8216;&#8217;) is returned.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body">ValueError if channel_name is invalid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.MultiEdgeSequence.at_end">
<tt class="descname">at_end</tt><big>(</big><em>channel_name=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence.at_end" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the sequences have ended</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>channel_name</strong> (<em>string</em>) &#8211; The name of the channel to test for termination</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: True when the named edge iterator has terminated. if channel_name is</p>
<blockquote>
<div>None, returns True when all channels in the set have terminated.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body">ValueError if channel_name is invalid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.MultiEdgeSequence.cur_state">
<tt class="descname">cur_state</tt><big>(</big><em>channel_name=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence.cur_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current state of the edge sets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>channel_name</strong> (<em>string</em>) &#8211; Name of the channel to retrieve state from</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: The value of the named channel&#8217;s state. if channel_name is none</p>
<blockquote>
<div>the state of all channels is returned as a list.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body">ValueError if channel_name is invalid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.MultiEdgeSequence.cur_time">
<tt class="descname">cur_time</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence.cur_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current time of the edge sets</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.decode.check_logic_levels">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">check_logic_levels</tt><big>(</big><em>samples</em>, <em>max_samples=20000</em>, <em>buf_size=2000</em><big>)</big><a class="headerlink" href="#ripyl.decode.check_logic_levels" title="Permalink to this definition">¶</a></dt>
<dd><p>Automatically determine the binary logic levels of a digital signal.</p>
<p>This is a wrapper for find_logic_levels() that handles teeing off
a buffered sample stream and raising AutoLevelError when detection
fails.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream. Each element is a SampleChunk containing
an array of samples. This iterator is internally tee&#8217;d and becomes
invalidated for further use. The return value includes a new sample
stream to retrieve samples from.</li>
<li><strong>max_samples</strong> (<em>int</em>) &#8211; The maximum number of samples to consume from the samples iterable.
This should be at least 2x buf_size and will be coerced to that value
if it is less.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:type buf_size: int
:param buf_size:</p>
<blockquote>
<div>The maximum size of the sample buffer to analyze for logic levels.
This should be less than max_samples.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A 2-tuple (sample steam, logic_levels) representing the buffered sample
stream and a tuple of the detected logic levels of the samples.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body">AutoLevelError if less than two peaks are found in the sample histogram.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.find_bot_top_hist_peaks">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">find_bot_top_hist_peaks</tt><big>(</big><em>raw_samples</em>, <em>bins</em>, <em>use_kde=False</em>, <em>kde_bw=0.05</em><big>)</big><a class="headerlink" href="#ripyl.decode.find_bot_top_hist_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the bottom and top peaks in a histogram of data sample magnitudes.
These are the left-most and right-most of the two largest peaks in the histogram.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>raw_samples</strong> (<em>sequence of numbers</em>) &#8211; A sequence representing the population of data samples that will be
analyzed for peaks</li>
<li><strong>bins</strong> (<em>int</em>) &#8211; The number of bins to use for the histogram</li>
<li><strong>use_kde</strong> (<em>bool</em>) &#8211; Boolean indicating whether to construct the histogram from a Kernel Density
Estimate. This is useful for approximating normally distributed peaks on
synthetic data sets lacking noise.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:type kde_bw: float
:param kde_bw:</p>
<blockquote>
<div>Float providing the bandwidth parameter for the KDE</div></blockquote>
<p>:param  :
:returns: A 2-tuple (bot, top) representing the bottom and top peaks. the value for</p>
<blockquote>
<div>each peak is the center of the histogram bin that represents the midpoint of the
population for that peak.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None if less than two peaks are found in the histogram</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body">ValueError if a KDE cannot be constructed</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.find_edges">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">find_edges</tt><big>(</big><em>samples</em>, <em>logic</em>, <em>hysteresis=0.4</em><big>)</big><a class="headerlink" href="#ripyl.decode.find_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the edges in a sampled digital waveform</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream. Each element is a SampleChunk containing
an array of samples.</li>
<li><strong>logic</strong> (<em>(float, float)</em>) &#8211; A 2-tuple (low, high) representing the mean logic levels in the sampled waveform</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:type hysteresis: float
:param hysteresis:</p>
<blockquote>
<div>A value between 0.0 and 1.0 representing the amount of hysteresis the use for
detecting valid edge crossings.</div></blockquote>
<p>:param  :
:returns: An iterator yielding  a series of 2-tuples (time, value) representing the time and</p>
<blockquote>
<div>logic value (0 or 1) for each edge transition. The first tuple
yielded is the initial state of the sampled waveform. All remaining
tuples are detected edges.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body">StreamError if the stream is empty</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.find_hist_peaks">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">find_hist_peaks</tt><big>(</big><em>hist</em>, <em>thresh_scale=1.0</em><big>)</big><a class="headerlink" href="#ripyl.decode.find_hist_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all peaks in a histogram
This uses a modification of the method employed by the &#8220;peaks&#8221; function in
LeCroy digital oscilloscopes. The original algorithm is described in various manuals
such as the 9300 WP03 manual or WavePro manual RevC 2002 (p16-14).</p>
<p>This algorithm works well for real world data sets where the histogram peaks are
normally distributed (i.e. there is some noise present in the data set).
For synthetic waveforms lacking noise or any intermediate samples between discrete
logic levels, the statistical measures used to determine the threshold for a peak
are not valid. The threshold t2 ends up being too large and valid peaks may be
excluded. To avoid this problem the histogram can be sampled from a KDE instead or
the thresh_scale parameter can be set to a lower value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hist</strong> (<em>sequence of int</em>) &#8211; A sequence representing the histogram bin counts. Typically the first parameter
returned by numpy.histogram() or a KDE from scipy.stats.gaussian_kde().</li>
<li><strong>thresh_scale</strong> (<em>float</em>) &#8211; Apply a scale factor to the internal threshold for peak classification.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: A list of peaks where each peak is a 2-tuple representing the</p>
<blockquote>
<div>start and end indices of the peak in hist.</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.find_logic_levels">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">find_logic_levels</tt><big>(</big><em>samples</em>, <em>max_samples=20000</em>, <em>buf_size=2000</em><big>)</big><a class="headerlink" href="#ripyl.decode.find_logic_levels" title="Permalink to this definition">¶</a></dt>
<dd><p>Automatically determine the binary logic levels of a digital signal.</p>
<p>This function consumes up to max_samples from samples in an attempt
to build a buffer containing a representative set of samples at high
and low logic levels. Less than max_samples may be consumed if an edge
is found and the remaining half of the buffer is filled before the
max_samples threshold is reached.</p>
<p>Warning: this function is insensitive to any edge transition that
occurs within the first 100 samples. If the distribution of samples
is heavily skewed toward one level over the other None may be returned.
To be reliable, a set of samples should contain more than one edge or
a solitary edge after the 400th sample.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream. Each element is a SampleChunk containing
an array of samples.</li>
<li><strong>max_samples</strong> (<em>int</em>) &#8211; The maximum number of samples to consume from the samples iterable.
This should be at least 2x buf_size and will be coerced to that value
if it is less.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:type buf_size: int
:param buf_size:</p>
<blockquote>
<div>The maximum size of the sample buffer to analyze for logic levels.
This should be less than max_samples.</div></blockquote>
<p>:param  :
:returns: A 2-tuple (low, high) representing the logic levels of the samples
:returns: None if less than two peaks are found in the sample histogram.</p>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.find_multi_edges">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">find_multi_edges</tt><big>(</big><em>samples</em>, <em>hyst_thresholds</em><big>)</big><a class="headerlink" href="#ripyl.decode.find_multi_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the multi-level edges in a sampled digital waveform</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<p>Note that the output of this function cannot be used directly without further
processing. Transitions across multiple states cannot be easily
distinguished from transitions incliding intermediate states.
For the case of three states (-1, 0, 1), Short periods in the 0 state
should be removed but this requires knowledge of the minimum time for a 0 state
to be valid. This is performed by the remove_transitional_states() function.</p>
<p>The logic state encoding is formulated to balance the number of positive and negative
states around 0 for odd numbers of states and with one extra positive state for even
state numbers. For 2 states the encoding is the usual (0,1). For 3: (-1, 0, 1).
For 4: (-1, 0, 1, 2). For 5: (-2, -1, 0, 1, 2), etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream. Each element is a SampleChunk containing
an array of samples.</li>
<li><strong>hyst_thresholds</strong> (<em>sequence of float</em>) &#8211; A sequence containing the hysteresis thresholds for the logic states.
For N states there should be (N-1) * 2 thresholds.
The gen_hyst_thresholds() function can compute these values from more
usual logic parameters. The numbers must be sorted in ascending order.
Every pair of numbers in the sequence forms the bounds of a hysteresis
band. Samples within these bands are considered transient states. Samples
outside these bands are the valid logic states.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of 2-tuples (time, int) representing the time and
logic value for each edge transition. The first tuple
yielded is the initial state of the sampled waveform. All remaining
tuples are detected edges.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">StreamError if the stream is empty</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.find_symbol_rate">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">find_symbol_rate</tt><big>(</big><em>edges</em>, <em>sample_rate=1.0</em>, <em>spectra=2</em>, <em>auto_span_limit=True</em>, <em>max_span_limit=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.find_symbol_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the base symbol rate from a set of edges</p>
<p>This function depends on the edge data containing a variety of spans between
edges all related to the fundamental symbol rate. The Harmonic Product Spectrum
(HPS) of the edge span values is calculated and used to isolate the fundamental
symbol rate. This function will not work properly on a clock signal containing
a single time span between edges due to the lack of higher fundementals needed
by the HPS unless spectra=1 which effectively disables the HPS operation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>edges</strong> (<em>[(float, int)...] or [(int, int)...]</em>) &#8211; <p>An iterable of 2-tuples representing each edge transition.
The tuples are in one of two forms:</p>
<blockquote>
<div><ul class="simple">
<li>absolute time  (time, logic level)</li>
<li>sample indexed (index, logic level)</li>
</ul>
</div></blockquote>
<p>This function will consume all elements of the edges iterable.
It must have a finite length</p>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:type sample_rate: float
:param sample_rate:</p>
<blockquote>
<div>An adjustment to convert the raw symbol rate from samples to time.
If the edges parameter is based on absolute time units then this
should remain the default value of 1.0.</div></blockquote>
<p>:param  :
:type spectra: int
:param spectra:</p>
<blockquote>
<div>The number of spectra to include in the calculation of the HPS. This
number should not larger than the highest harmonic in the edge span
data.</div></blockquote>
<p>:param  :
:type auto_span_limit: bool
:param auto_span_limit:</p>
<blockquote>
<div>Excessively long edge spans can impair the symbol rate detection by
reducing the resolution of the HPS. They are typically the result of
long idle periods between the interesting parts we want to estimate
the symbol rate from. When this parameter is True, an attempt is made
to find the ideal limit for the spans included in the HPS.</div></blockquote>
<p>:param  :
:type max_span_limit: int
:param max_span_limit:</p>
<blockquote>
<div>An optional upper limit for span length to include in the HPS.
auto_span_limit must be False for this to take effect.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The estimated symbol rate of the edge data set as an int</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body">ValueError if there are not enough edge spans to evaluate
a HPS.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.gen_histogram">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">gen_histogram</tt><big>(</big><em>raw_samples</em>, <em>bins</em>, <em>use_kde=False</em>, <em>kde_bw=0.05</em><big>)</big><a class="headerlink" href="#ripyl.decode.gen_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a histogram using either normal binning or a KDE</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>raw_samples</strong> (<em>sequence of numbers</em>) &#8211; A sequence representing the population of data samples that will be
analyzed for peaks</li>
<li><strong>bins</strong> (<em>int</em>) &#8211; The number of bins to use for the histogram</li>
<li><strong>use_kde</strong> (<em>bool</em>) &#8211; Boolean indicating whether to construct the histogram from a Kernel Density
Estimate. This is useful for approximating normally distributed peaks on
synthetic data sets lacking noise.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:type kde_bw: float
:param kde_bw:</p>
<blockquote>
<div>Float providing the bandwidth parameter for the KDE</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A tuple (hist, bin_centers) containing lists of the histogram bins and
the center value of each bin.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body">ValueError if a KDE cannot be constructed</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.gen_hyst_thresholds">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">gen_hyst_thresholds</tt><big>(</big><em>logic_levels</em>, <em>hysteresis=0.1</em><big>)</big><a class="headerlink" href="#ripyl.decode.gen_hyst_thresholds" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate hysteresis thresholds for find_multi_edges()</p>
<p>This function computes the hysteresis thresholds for multi-level edge finding
with find_multi_edges().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>logic_levels</strong> (<em>sequence of float</em>) &#8211; A sequence of the nominal voltage levels for each logic state sorted
in ascending order.</li>
<li><strong>hysteresis</strong> (<em>float</em>) &#8211; A value between 0.0 and 1.0 representing the amount of hysteresis the use for
detecting valid edge crossings.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of floats. every pair of numbers represents a hysteresis band.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.remove_transitional_states">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">remove_transitional_states</tt><big>(</big><em>edges</em>, <em>min_state_period</em><big>)</big><a class="headerlink" href="#ripyl.decode.remove_transitional_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter out brief transitional states from an edge stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>edges</strong> (<em>iterable of (float, int) tuples</em>) &#8211; An iterable of 2-tuples representing each edge transition.
The 2-tuples <em>must</em> be in the absolute time form (time, logic level).</li>
<li><strong>min_state_period</strong> (<em>float</em>) &#8211; The threshold for transitional states. A transition lasting less than this
threshold will be filtered out of the edge stream.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of 2-tuples (time, value) representing the time and
logic value for each edge transition. The first tuple yielded is the
initial state of the sampled waveform. All remaining tuples are
detected edges.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">StreamError if the stream is empty</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.sigproc">
<span id="sigproc-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">sigproc</span></tt> Module<a class="headerlink" href="#module-ripyl.sigproc" title="Permalink to this headline">¶</a></h2>
<p>General routines for signal processing of streaming waveforms</p>
<dl class="function">
<dt id="ripyl.sigproc.amplify">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">amplify</tt><big>(</big><em>samples</em>, <em>gain=1.0</em>, <em>offset=0.0</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.amplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply gain and offset to a sample stream</p>
<p>This modifies samples such that output = input * gain + offset.</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream to modify.</li>
<li><strong>gain</strong> (<em>float</em>) &#8211; The gain multiplier for the samples</li>
<li><strong>offset</strong> (<em>float</em>) &#8211; The additive offset for the samples</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.approximate_bandwidth">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">approximate_bandwidth</tt><big>(</big><em>rise_time</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.approximate_bandwidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine an approximate bandwidth for a signal with a known rise time</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rise_time</strong> (<em>float</em>) &#8211; A rise time to compute bandwidth from</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The bandwidth for the rise time.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.capacify">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">capacify</tt><big>(</big><em>samples</em>, <em>capacitance</em>, <em>resistance=1.0</em>, <em>iterations=80</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.capacify" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate an RC filter on a waveform:</p>
<div class="highlight-python"><pre>: samples &gt;--R--+--&gt; out
:               |
:               C
:              _|_</pre>
</div>
<p>Warning: This function becomes unstable for small time constants (C * R).
It is implemented with a simple application of the RC difference equations.
The time step (dt) is taken from the sample period of each sample chunk divided
by the number of iterations. The results will be inaccurate for large values of
dt but still largely representative of the expected behavior.</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream to modify.</li>
<li><strong>capacitance</strong> (<em>float</em>) &#8211; The capacitance value. If resistance is kept at the default value of 1.0 Ohms
this parameter is equivalent to the time constant tau (c = tau / r).</li>
<li><strong>resistance</strong> (<em>float</em>) &#8211; The resistance value</li>
<li><strong>iterations</strong> (<em>int</em>) &#8211; The number of iterations to calculate each sample. You can experience numeric
instability if this value is too low.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.chain">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">chain</tt><big>(</big><em>stream_gap_time</em>, <em>*streams</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine a sequence of sample streams together.</p>
<p>A set of sample streams are concatenated together with updated time
stamps to maintain monotonically increasing time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stream_gap_time</strong> (<em>float</em>) &#8211; The time interval added between successive streams</li>
<li><strong>streams</strong> (<em>sequence of iterables containing SampleChunk objects</em>) &#8211; A sequence of streams</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream representing the data from each stream in order</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.chain_edges">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">chain_edges</tt><big>(</big><em>stream_gap_time</em>, <em>*streams</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.chain_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine a sequence of edge streams together.</p>
<p>A set of edge streams are concatenated together with updated time
stamps to maintain monotonically increasing time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stream_gap_time</strong> (<em>float</em>) &#8211; The time interval added between successive streams</li>
<li><strong>streams</strong> (<em>sequence of sequences containing (float, number) tuples</em>) &#8211; A sequence of streams</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  an edge stream representing the data from each stream in order</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.dropout">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">dropout</tt><big>(</big><em>samples</em>, <em>start_time</em>, <em>end_time</em>, <em>val=0.0</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.dropout" title="Permalink to this definition">¶</a></dt>
<dd><p>Force a sample stream to a fixed level</p>
<p>This simulates the effect of a dropout in data transmission by
repacing samples with a fixed value.</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream to modify.</li>
<li><strong>start_time</strong> (<em>float</em>) &#8211; Start of the dropout phase</li>
<li><strong>end_time</strong> (<em>float</em>) &#8211; End of the dropout phase</li>
<li><strong>val</strong> (<em>float</em>) &#8211; The sample value to substitute during the dropout phase</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.edges_to_sample_stream">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">edges_to_sample_stream</tt><big>(</big><em>edges</em>, <em>sample_period</em>, <em>logic_states=(0</em>, <em>1)</em>, <em>end_extension=None</em>, <em>chunk_size=10000</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.edges_to_sample_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an edge stream to a sample stream</p>
<p>The output samples are scaled to the range of 0.0 to 1.0 regardless of the number of logic states.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>edges</strong> (<em>iterable of (float, int) tuples</em>) &#8211; An edge stream to sample</td>
</tr>
</tbody>
</table>
<p>:param  :
:type sample_period: float
:param sample_period:</p>
<blockquote>
<div>The sample period for converting the edge stream</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>logic_states</strong> (<em>sequence of int</em>) &#8211; The coded state values for the lowest and highest state in the edge stream.
For 2-level states these will be (0,1). For 3-level: (-1, 1). For 5-level: (-2, 2).</td>
</tr>
</tbody>
</table>
<p>:param  :
:type end_extension: float
:param end_extension:</p>
<blockquote>
<div>Optional amount of time to add to the end after the last edge transition</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>chunk_size</strong> (<em>int</em>) &#8211; Number of samples in each SampleChunk</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An iterator yielding  a stream of SampleChunk objects.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.filter_waveform">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">filter_waveform</tt><big>(</big><em>samples</em>, <em>sample_rate</em>, <em>rise_time</em>, <em>ripple_db=60.0</em>, <em>chunk_size=10000</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.filter_waveform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a bandwidth limiting low-pass filter to a sample stream</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream to be filtered.</li>
<li><strong>sample_rate</strong> (<em>float</em>) &#8211; The sample rate for converting the sample stream.</li>
<li><strong>rise_time</strong> (<em>float</em>) &#8211; Rise (and fall) time for the filtered samples.</li>
<li><strong>ripple_db</strong> (<em>float</em>) &#8211; Noise suppression in dB for the bandwidth filter stop band. This should
be a positive value.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:type chunk_size: int
:param chunk_size:</p>
<blockquote>
<div>Internal FIR filter sample pool size. This can generally be ignored. To support
streaming of samples, the FIR filter operation is done piecewise so we don&#8217;t have
to consume the entire input before producing filtered output. Larger values will
reduce the number of filter operations performed. Excessively small values will
waste time due to the reprocessing of overlapping samples between successive pools.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An iterator yielding  a stream of SampleChunk objects.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.invert">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">invert</tt><big>(</big><em>stream</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert the polarity of stream values</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream to modify.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An iterator yielding  a sample stream.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.min_rise_time">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">min_rise_time</tt><big>(</big><em>sample_rate</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.min_rise_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the minimum rise time for a sample rate</p>
<p>This function is useful to determine the minimum rise time acceptable as parameters
to filter_waveform() and synth_wave(). You should use a scale factor to incease the rise
time at least slightly (e.g. rt * 1.01) to avoid raising a ValueError in those functions
due to floating point inaccuracies.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sample_rate</strong> (<em>number</em>) &#8211; The sample rate to determine rise time from</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A float for the minimum acceptable rise time.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.noisify">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">noisify</tt><big>(</big><em>samples</em>, <em>snr_db=30.0</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.noisify" title="Permalink to this definition">¶</a></dt>
<dd><p>Add noise to a sample stream</p>
<p>This modifies samples with additive, normally distributed noise</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream to modify.</li>
<li><strong>snr_db</strong> (<em>float</em>) &#8211; The Signal to Noise Ratio in dB. This value is only accurate if the
input samples are normalized to the range 0.0 to 1.0. Any amplification
should be applied after noisify() for the SNR to be correct.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.quantize">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">quantize</tt><big>(</big><em>samples</em>, <em>full_scale</em>, <em>bits=8</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.quantize" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantize samples to simulate oscilloscope quantization error</p>
<p>This should be applied to a noisy signal to have notable results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream to modify.</td>
</tr>
</tbody>
</table>
<p>:param  :
:type full_scale: float
:param full_scale:</p>
<blockquote>
<div>The full scale range for digitizer being emulated. For example,
a scope with 8 vertical divisions set at 2V/div. will have a
full scale range of 2V*8 = 16V</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bits</strong> (<em>int</em>) &#8211; The number of bits to quantize to</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An iterator yielding  a sample stream.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.remove_excess_edges">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">remove_excess_edges</tt><big>(</big><em>edges</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.remove_excess_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove incorrect edge transitions from an edge stream</p>
<p>This is a generator function.</p>
<p>This function is most useful for conditioning the outputs of the protocol
synthesizers. For those protocols with multiple signals, the synthesizers
myst yield a new output set for <em>all</em> signals when any <em>one</em> of them changes.
This results in non-conforming edge streams that contain multiple consecutive
pairs with a non-changing value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>edges</strong> (<em>iterable of (float, int) tuples</em>) &#8211; An edge stream to filter for extraneous non-edges</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: An iterator yielding  an edge stream.</p>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.sum_streams">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">sum_streams</tt><big>(</big><em>stream1</em>, <em>stream2</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.sum_streams" title="Permalink to this definition">¶</a></dt>
<dd><p>Add two sample streams together</p>
<p>The time elements of each stream will not be aligned if they do not match.
Instead the time values from stream1 are used for the result. The iterator
terminates when either of the two streams ends.</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>stream1</strong> (<em>iterable of SampleChunk objects</em>) &#8211; </li>
<li><strong>stream2</strong> (<em>iterable of SampleChunk objects</em>) &#8211; The two sample streams to have their corresponding values added together.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: An iterator yielding  a sample stream.</p>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.synth_wave">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">synth_wave</tt><big>(</big><em>edges</em>, <em>sample_rate</em>, <em>rise_time</em>, <em>tau_factor=0.0</em>, <em>logic_states=(0</em>, <em>1)</em>, <em>ripple_db=60.0</em>, <em>chunk_size=10000</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.synth_wave" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an edge stream to a sampled waveform with band limited rise/fall times</p>
<p>This is a convenience function combining edges_to_sample_stream(),
filter_waveform(), and (optionally) capacify().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>edges</strong> (<em>sequence of (float, int) tuples</em>) &#8211; An edge stream to be sampled</li>
<li><strong>sample_rate</strong> (<em>float</em>) &#8211; The sample rate for converting the edge stream</li>
<li><strong>rise_time</strong> (<em>float</em>) &#8211; Rise (and fall) time for the filtered samples</li>
<li><strong>tau_factor</strong> (<em>float</em>) &#8211; The scale factor used to derive a capacify() time constant from the rise_time
such that tau = rise_time * tau_factor. The capacify operation is skipped
if tau_factor is &lt; 0.01.</li>
<li><strong>logic_states</strong> (<em>sequence of int</em>) &#8211; The coded state values for the lowest and highest state in the edge stream.
For 2-level states these will be (0,1). For 3-level: (-1, 1). For 5-level: (-2, 2).</li>
<li><strong>ripple_db</strong> (<em>float</em>) &#8211; Noise suppression in dB for the bandwidth filter stop band. This should
be a positive value.</li>
<li><strong>chunk_size</strong> (<em>int</em>) &#8211; Number of samples in each SampleChunk</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator for the synthesized sample stream</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.streaming">
<span id="streaming-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">streaming</span></tt> Module<a class="headerlink" href="#module-ripyl.streaming" title="Permalink to this headline">¶</a></h2>
<p>Data streaming common classes</p>
<dl class="class">
<dt id="ripyl.streaming.AnnotationFormat">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">AnnotationFormat</tt><a class="headerlink" href="#ripyl.streaming.AnnotationFormat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration of annotation data formats</p>
<dl class="attribute">
<dt id="ripyl.streaming.AnnotationFormat.Bin">
<tt class="descname">Bin</tt><em class="property"> = 7</em><a class="headerlink" href="#ripyl.streaming.AnnotationFormat.Bin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.AnnotationFormat.Enum">
<tt class="descname">Enum</tt><em class="property"> = 8</em><a class="headerlink" href="#ripyl.streaming.AnnotationFormat.Enum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.AnnotationFormat.General">
<tt class="descname">General</tt><em class="property"> = 2</em><a class="headerlink" href="#ripyl.streaming.AnnotationFormat.General" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.AnnotationFormat.Hex">
<tt class="descname">Hex</tt><em class="property"> = 6</em><a class="headerlink" href="#ripyl.streaming.AnnotationFormat.Hex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.AnnotationFormat.Hidden">
<tt class="descname">Hidden</tt><em class="property"> = 0</em><a class="headerlink" href="#ripyl.streaming.AnnotationFormat.Hidden" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.AnnotationFormat.Int">
<tt class="descname">Int</tt><em class="property"> = 5</em><a class="headerlink" href="#ripyl.streaming.AnnotationFormat.Int" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.AnnotationFormat.Invisible">
<tt class="descname">Invisible</tt><em class="property"> = 1</em><a class="headerlink" href="#ripyl.streaming.AnnotationFormat.Invisible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.AnnotationFormat.String">
<tt class="descname">String</tt><em class="property"> = 3</em><a class="headerlink" href="#ripyl.streaming.AnnotationFormat.String" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.AnnotationFormat.Text">
<tt class="descname">Text</tt><em class="property"> = 4</em><a class="headerlink" href="#ripyl.streaming.AnnotationFormat.Text" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="ripyl.streaming.AutoLevelError">
<em class="property">exception </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">AutoLevelError</tt><big>(</big><em>msg='Unable to find avg. logic levels of waveform'</em><big>)</big><a class="headerlink" href="#ripyl.streaming.AutoLevelError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.streaming.StreamError" title="ripyl.streaming.StreamError"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamError</span></tt></a></p>
<p>Custom exception class auto-level errors</p>
<dl class="method">
<dt id="ripyl.streaming.AutoLevelError.__init__">
<tt class="descname">__init__</tt><big>(</big><em>msg='Unable to find avg. logic levels of waveform'</em><big>)</big><a class="headerlink" href="#ripyl.streaming.AutoLevelError.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.ChunkExtractor">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">ChunkExtractor</tt><big>(</big><em>stream</em><big>)</big><a class="headerlink" href="#ripyl.streaming.ChunkExtractor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Utility class that pulls arbitrarily sized chunks from a sample stream</p>
<dl class="method">
<dt id="ripyl.streaming.ChunkExtractor.__init__">
<tt class="descname">__init__</tt><big>(</big><em>stream</em><big>)</big><a class="headerlink" href="#ripyl.streaming.ChunkExtractor.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.streaming.ChunkExtractor.buffered_chunk">
<tt class="descname">buffered_chunk</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.streaming.ChunkExtractor.buffered_chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all remaining buffered samples</p>
</dd></dl>

<dl class="method">
<dt id="ripyl.streaming.ChunkExtractor.next_chunk">
<tt class="descname">next_chunk</tt><big>(</big><em>chunk_size=10000</em><big>)</big><a class="headerlink" href="#ripyl.streaming.ChunkExtractor.next_chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a new chunk of samples from the stream</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>chunk_size</strong> (<em>int</em>) &#8211; The number of samples for this chunk.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A samplechunk object. if the stream had fewer than chunk_size samples
remaining then the SampleChunk.samples array is sized to hold only those samples.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None if the stream has ended.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.streaming.ChunkExtractor.next_samples">
<tt class="descname">next_samples</tt><big>(</big><em>sample_count=10000</em><big>)</big><a class="headerlink" href="#ripyl.streaming.ChunkExtractor.next_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a new set of raw samples from the stream</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sample_count</strong> (<em>int</em>) &#8211; The number of samples for the array.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A numpy array of float. if the stream had fewer than sample_count samples
remaining then the array is sized to hold only those samples.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None if the stream has ended.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.SampleChunk">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">SampleChunk</tt><big>(</big><em>samples</em>, <em>start_time</em>, <em>sample_period</em><big>)</big><a class="headerlink" href="#ripyl.streaming.SampleChunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>&#8216;Sample stream object</p>
<p>This represents a &#8220;chunk&#8221; of samples contained in a numpy array
stored in the samples attribute.</p>
<dl class="method">
<dt id="ripyl.streaming.SampleChunk.__init__">
<tt class="descname">__init__</tt><big>(</big><em>samples</em>, <em>start_time</em>, <em>sample_period</em><big>)</big><a class="headerlink" href="#ripyl.streaming.SampleChunk.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="ripyl.streaming.StreamError">
<em class="property">exception </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">StreamError</tt><a class="headerlink" href="#ripyl.streaming.StreamError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.RuntimeError</span></tt></p>
<p>Custom exception class for edge and sample streams</p>
</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.StreamEvent">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">StreamEvent</tt><big>(</big><em>time</em>, <em>data=None</em>, <em>kind='unknown event'</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.streaming.StreamRecord" title="ripyl.streaming.StreamRecord"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamRecord</span></tt></a></p>
<p>A stream element that occurs at a specific point in time</p>
<dl class="method">
<dt id="ripyl.streaming.StreamEvent.__init__">
<tt class="descname">__init__</tt><big>(</big><em>time</em>, <em>data=None</em>, <em>kind='unknown event'</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamEvent.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.streaming.StreamEvent.summary">
<tt class="descname">summary</tt><big>(</big><em>a=None</em>, <em>depth=0</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamEvent.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield string(s) summarizing this segment and all of its subrecords
:type a: StreamRecord or None
:param a:</p>
<blockquote>
<div>StreamRecord to produce summary from. Uses self if None.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>depth</strong> (<em>int</em>) &#8211; Indentation level for this summary</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.StreamRecord">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">StreamRecord</tt><big>(</big><em>kind='unknown'</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class for protocol decoder output stream objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>kind</strong> &#8211; A string identifying the kind of record</li>
<li><strong>status</strong> &#8211; An integer status code</li>
<li><strong>stream_id</strong> &#8211; A unique numeric stream identifier</li>
<li><strong>subrecords</strong> &#8211; A list of child StreamRecord objects</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :</p>
<dl class="method">
<dt id="ripyl.streaming.StreamRecord.__init__">
<tt class="descname">__init__</tt><big>(</big><em>kind='unknown'</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamRecord.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.streaming.StreamRecord.annotate">
<tt class="descname">annotate</tt><big>(</big><em>style=None</em>, <em>fields=None</em>, <em>data_format=2</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamRecord.annotate" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8216;Set annotation attributes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>style</strong> (<em>string or None</em>) &#8211; The name of a style to use for drawing a rectangle representing this record</td>
</tr>
</tbody>
</table>
<p>:type  : as defined in ripyl.util.plot.annotation_styles
:param  :</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fields</strong> (<em>dict of string:value</em>) &#8211; A set of arbitrary info fields that may be displayed as attributes of this record.
The special field &#8216;_bits&#8217; identifies the number of data bits in this record
The special field &#8216;_enum&#8217; identifies an enumeration type for this record&#8217;s data attribute
The special field &#8216;value&#8217; is a string that will override any other source of label text</li>
<li><strong>data_format</strong> (<em>AnnotationFormat</em>) &#8211; The format for the text label</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.streaming.StreamRecord.nested_status">
<tt class="descname">nested_status</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamRecord.nested_status" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The highest status value from this record and its subrecords</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="ripyl.streaming.StreamRecord.status_text">
<em class="property">classmethod </em><tt class="descname">status_text</tt><big>(</big><em>status</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamRecord.status_text" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The string representation of a status code</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.streaming.StreamRecord.text">
<tt class="descname">text</tt><big>(</big><em>default_format=3</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamRecord.text" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a string representation of this segment&#8217;s data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>default_format</strong> (<em>AnnotationFormat</em>) &#8211; Set the format to use when the data_format attribute is General</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.StreamSegment">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">StreamSegment</tt><big>(</big><em>time_bounds</em>, <em>data=None</em>, <em>kind='unknown segment'</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamSegment" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.streaming.StreamRecord" title="ripyl.streaming.StreamRecord"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamRecord</span></tt></a></p>
<p>A stream element that spans two points in time</p>
<dl class="method">
<dt id="ripyl.streaming.StreamSegment.__init__">
<tt class="descname">__init__</tt><big>(</big><em>time_bounds</em>, <em>data=None</em>, <em>kind='unknown segment'</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamSegment.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.StreamSegment.end_time">
<tt class="descname">end_time</tt><a class="headerlink" href="#ripyl.streaming.StreamSegment.end_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.StreamSegment.start_time">
<tt class="descname">start_time</tt><a class="headerlink" href="#ripyl.streaming.StreamSegment.start_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.streaming.StreamSegment.summary">
<tt class="descname">summary</tt><big>(</big><em>a=None</em>, <em>depth=0</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamSegment.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield string(s) summarizing this segment and all of its subrecords
:type a: StreamRecord or None
:param a:</p>
<blockquote>
<div>StreamRecord to produce summary from. Uses self if None.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>depth</strong> (<em>int</em>) &#8211; Indentation level for this summary</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.StreamStatus">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">StreamStatus</tt><a class="headerlink" href="#ripyl.streaming.StreamStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration for standard stream status codes</p>
<dl class="attribute">
<dt id="ripyl.streaming.StreamStatus.Error">
<tt class="descname">Error</tt><em class="property"> = 200</em><a class="headerlink" href="#ripyl.streaming.StreamStatus.Error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.StreamStatus.Ok">
<tt class="descname">Ok</tt><em class="property"> = 0</em><a class="headerlink" href="#ripyl.streaming.StreamStatus.Ok" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.StreamStatus.Warning">
<tt class="descname">Warning</tt><em class="property"> = 100</em><a class="headerlink" href="#ripyl.streaming.StreamStatus.Warning" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.StreamType">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">StreamType</tt><a class="headerlink" href="#ripyl.streaming.StreamType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration for stream types</p>
<dl class="attribute">
<dt id="ripyl.streaming.StreamType.Edges">
<tt class="descname">Edges</tt><em class="property"> = 0</em><a class="headerlink" href="#ripyl.streaming.StreamType.Edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.StreamType.Samples">
<tt class="descname">Samples</tt><em class="property"> = 1</em><a class="headerlink" href="#ripyl.streaming.StreamType.Samples" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.extract_all_samples">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">extract_all_samples</tt><big>(</big><em>samples</em><big>)</big><a class="headerlink" href="#ripyl.streaming.extract_all_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all samples from a sample stream along with parameter information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; The sample stream to extract samples from.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A tuple containing a numpy sample array of float, the start time,
and the sample period.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.extract_samples">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">extract_samples</tt><big>(</big><em>samples</em>, <em>sample_count=10000</em><big>)</big><a class="headerlink" href="#ripyl.streaming.extract_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new gerator that yields sample arrays of the desired size</p>
<p>This is a generator function. Its send() method can be used to change the
value of sample_count mid-stream.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; The sample stream to extract samples from.</li>
<li><strong>sample_count</strong> (<em>int</em>) &#8211; The number of samples for the arrays.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a series of numpy arrays. If the stream has fewer than sample_count samples
remaining then the array is sized to hold only those samples.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.load_stream">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">load_stream</tt><big>(</big><em>fh</em><big>)</big><a class="headerlink" href="#ripyl.streaming.load_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore a stream of StreamRecord objects from a file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fh</strong> (<em>file-like object or a string</em>) &#8211; File to load records from. If a file handle is passed it should have been opened
in &#8216;rb&#8217; mode. If a string is passed it is the name of a file to read from.</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: A list of streamrecord objects</p>
</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.merge_streams">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">merge_streams</tt><big>(</big><em>records_a</em>, <em>records_b</em>, <em>id_a=0</em>, <em>id_b=1</em><big>)</big><a class="headerlink" href="#ripyl.streaming.merge_streams" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine two streams of StreamRecord objects.
Records with time signatures from each input stream are kept in chronological order.
:param  :
:type records_a: StreamRecord
:param records_a:</p>
<blockquote>
<div>Source records from stream a</div></blockquote>
<p>:param  :
:type records_b: StreamRecord
:param records_b:</p>
<blockquote>
<div>Source records from stream b</div></blockquote>
<p>:param  :
:type id_a: int
:param id_a:</p>
<blockquote>
<div>stream_id assigned to records from records_a</div></blockquote>
<p>:param  :
:type id_b: int
:param id_b:</p>
<blockquote>
<div>stream_id assigned to records from records_b</div></blockquote>
<p>:param  :
:returns: An iterator yielding  a stream of StreamRecord objects.</p>
</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.rechunkify">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">rechunkify</tt><big>(</big><em>samples</em>, <em>chunk_size=10000</em><big>)</big><a class="headerlink" href="#ripyl.streaming.rechunkify" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new gerator that yields SampleChunk objects of the desired size</p>
<p>This is a generator function. Its send() method can be used to change the
value of chunk_size mid-stream.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; The sample stream to extract SampleChunk objects from.</li>
<li><strong>chunk_size</strong> (<em>int</em>) &#8211; The number of samples for the SampleChunk objects.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a series of SampleChunk objects. If the stream has fewer than chunk_size samples
remaining then the SampleChunk.samples array is sized to hold only those samples.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.sample_stream_to_samples">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">sample_stream_to_samples</tt><big>(</big><em>samples</em><big>)</big><a class="headerlink" href="#ripyl.streaming.sample_stream_to_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all samples from a sample stream as an array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; The sample stream to extract samples from.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A numpy array of float.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.samples_to_sample_stream">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">samples_to_sample_stream</tt><big>(</big><em>raw_samples</em>, <em>sample_period</em>, <em>start_time=0.0</em>, <em>chunk_size=10000</em><big>)</big><a class="headerlink" href="#ripyl.streaming.samples_to_sample_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert raw samples to a chunked sample stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>raw_samples</strong> (<em>iterable of numbers</em>) &#8211; The samples to convert to a sample stream.</li>
<li><strong>sample_period</strong> (<em>float</em>) &#8211; The time interval between samples</li>
<li><strong>start_time</strong> (<em>float</em>) &#8211; The time for the first sample</li>
<li><strong>chunk_size</strong> (<em>int</em>) &#8211; The maximum number of samples for each chunk</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a series of SampleChunk objects representing the time and
sample value for each input sample. This can be fed to functions
that expect a chunked sample stream as input.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.save_stream">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">save_stream</tt><big>(</big><em>records</em>, <em>fh</em><big>)</big><a class="headerlink" href="#ripyl.streaming.save_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a stream of StreamRecord objects to a file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>records</strong> (<em>StreamRecord sequence</em>) &#8211; The StreamRecord objects to save.</li>
<li><strong>fh</strong> (<em>file-like object or a string</em>) &#8211; File to save records to. If a file handle is passed it should have been
opened in &#8216;wb&#8217; mode. If a string is passed it is the name of a file to write to.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">TypeError when records parameter is not a sequence.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.wave_synth">
<span id="wave-synth-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">wave_synth</span></tt> Module<a class="headerlink" href="#module-ripyl.wave_synth" title="Permalink to this headline">¶</a></h2>
<p>General routines for synthesizing basic waveforms</p>
<dl class="function">
<dt id="ripyl.wave_synth.sine_synth">
<tt class="descclassname">ripyl.wave_synth.</tt><tt class="descname">sine_synth</tt><big>(</big><em>frequency=1000000.0</em>, <em>phase=0.0</em>, <em>sample_period=5e-08</em>, <em>samples=None</em><big>)</big><a class="headerlink" href="#ripyl.wave_synth.sine_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Sine generator</p>
<p>Will generate a continuous stream of samples from a sine wave.
This generator will terminate if the number of output samples is specified.
:param  :
:type frequency: float
:param frequency:</p>
<blockquote>
<div>Frequency in Hz of the sine wave</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>phase</strong> (<em>float</em>) &#8211; Phase in radians of the sine wave</li>
<li><strong>sample_period</strong> (<em>float</em>) &#8211; Time interval between samples</li>
<li><strong>samples</strong> (<em>int</em>) &#8211; Optional number of samples to generate</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: An iterator yielding  a series of raw samples.</p>
</dd></dl>

<dl class="function">
<dt id="ripyl.wave_synth.square_synth">
<tt class="descclassname">ripyl.wave_synth.</tt><tt class="descname">square_synth</tt><big>(</big><em>frequency=1000000.0</em>, <em>duty=0.5</em>, <em>phase=0.0</em>, <em>sample_period=5e-08</em>, <em>samples=None</em><big>)</big><a class="headerlink" href="#ripyl.wave_synth.square_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Square wave generator</p>
<p>Will generate a continuous stream of samples from a square wave.
This generator will terminate if the number of output samples is specified.
:param  :
:type frequency: float
:param frequency:</p>
<blockquote>
<div>Frequency in Hz of the square wave</div></blockquote>
<p>:param  :
:type duty: float
:param duty:</p>
<blockquote>
<div>Duty cycle of the square wave. Should be between 0.0 and 1.0.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>phase</strong> (<em>float</em>) &#8211; Phase of the square wave in fractions of a period. Should be between 0.0 and 1.0.</li>
<li><strong>sample_period</strong> (<em>float</em>) &#8211; Time interval between samples</li>
<li><strong>samples</strong> (<em>int</em>) &#8211; Optional number of samples to generate</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: An iterator yielding  a series of raw samples.</p>
</dd></dl>

</div>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="ripyl.protocol.html">protocol Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#id1"><tt class="docutils literal"><span class="pre">protocol</span></tt> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.can"><tt class="docutils literal"><span class="pre">can</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.i2c"><tt class="docutils literal"><span class="pre">i2c</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.iso_k_line"><tt class="docutils literal"><span class="pre">iso_k_line</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.lin"><tt class="docutils literal"><span class="pre">lin</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.lm73"><tt class="docutils literal"><span class="pre">lm73</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.obd2"><tt class="docutils literal"><span class="pre">obd2</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.ps2"><tt class="docutils literal"><span class="pre">ps2</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.sagem_ecu"><tt class="docutils literal"><span class="pre">sagem_ecu</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.spi"><tt class="docutils literal"><span class="pre">spi</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.uart"><tt class="docutils literal"><span class="pre">uart</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.usb"><tt class="docutils literal"><span class="pre">usb</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.usb_transact"><tt class="docutils literal"><span class="pre">usb_transact</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ripyl.protocol.infrared.html">infrared Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ripyl.protocol.infrared.html#id1"><tt class="docutils literal"><span class="pre">infrared</span></tt> Package</a></li>
<li class="toctree-l4"><a class="reference internal" href="ripyl.protocol.infrared.html#module-ripyl.protocol.infrared.ir_common"><tt class="docutils literal"><span class="pre">ir_common</span></tt> Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="ripyl.protocol.infrared.html#module-ripyl.protocol.infrared.nec"><tt class="docutils literal"><span class="pre">nec</span></tt> Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="ripyl.protocol.infrared.html#module-ripyl.protocol.infrared.rc5"><tt class="docutils literal"><span class="pre">rc5</span></tt> Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="ripyl.protocol.infrared.html#module-ripyl.protocol.infrared.rc6"><tt class="docutils literal"><span class="pre">rc6</span></tt> Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="ripyl.protocol.infrared.html#module-ripyl.protocol.infrared.sirc"><tt class="docutils literal"><span class="pre">sirc</span></tt> Module</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ripyl.util.html">util Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#id1"><tt class="docutils literal"><span class="pre">util</span></tt> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#module-ripyl.util.bitops"><tt class="docutils literal"><span class="pre">bitops</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#module-ripyl.util.eng"><tt class="docutils literal"><span class="pre">eng</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#module-ripyl.util.enum"><tt class="docutils literal"><span class="pre">enum</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#module-ripyl.util.equality"><tt class="docutils literal"><span class="pre">equality</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#module-ripyl.util.plot"><tt class="docutils literal"><span class="pre">plot</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#module-ripyl.util.stats"><tt class="docutils literal"><span class="pre">stats</span></tt> Module</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/Ripyl logo 100px.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">ripyl Package</a><ul>
<li><a class="reference internal" href="#id1"><tt class="docutils literal"><span class="pre">ripyl</span></tt> Package</a></li>
<li><a class="reference internal" href="#module-ripyl.config"><tt class="docutils literal"><span class="pre">config</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.decode"><tt class="docutils literal"><span class="pre">decode</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.sigproc"><tt class="docutils literal"><span class="pre">sigproc</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.streaming"><tt class="docutils literal"><span class="pre">streaming</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.wave_synth"><tt class="docutils literal"><span class="pre">wave_synth</span></tt> Module</a></li>
<li><a class="reference internal" href="#subpackages">Subpackages</a><ul>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="modules.html"
                        title="previous chapter">ripyl</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="ripyl.protocol.html"
                        title="next chapter">protocol Package</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/apidoc/ripyl.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ripyl.protocol.html" title="protocol Package"
             >next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="ripyl"
             >previous</a> |</li>
        <li><a href="../index.html">Ripyl 1.2 documentation</a> &raquo;</li>
          <li><a href="modules.html" >ripyl</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer">
        &copy; Copyright 2013, Kevin Thibedeau.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>

<script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43149311-1', 'google.com');
  ga('send', 'pageview');

</script>

  </body>
</html>